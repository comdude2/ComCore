package net.comdude2.plugins.minecraftcore.encryption;

import java.io.Serializable;
import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.security.AlgorithmParameters;
import java.security.SecureRandom;
import java.security.spec.KeySpec;
import java.util.LinkedList;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

/**
 * AES encryption class
 * @author Matt Armer
 */
public final class AES implements Serializable{
	
	/*
	 * YOU MUST SAVE THE IV BYTES!
	 */
	
	private static final long serialVersionUID = -6369897456619090832L;
	private String password = null;
	private byte[] salt = null;
	private int keySize = 128;
	private final int keyIterations = 65536;
	
	private SecretKey key = null;
	
	//Static variables
	private static final String splitSequence = "::/::";
	
	/**
	 * Create a new instance
	 * @param password
	 * @param keySize
	 */
	public AES(String password, int keySize){
		this.password = password;
		this.salt = generateSalt();
		this.keySize = keySize;
	}
	
	/**
	 * Create a new instance
	 * @param password
	 * @param salt
	 * @param keySize
	 */
	public AES(String password, byte[] salt, int keySize){
		this.password = password;
		this.salt = salt;
		this.keySize = keySize;
	}
	
	/**
	 * Create a SecretKey object based on the password, salt and keySize variables
	 * @throws Exception
	 * @throws java.security.InvalidKeyException
	 */
	public void createSecretKey() throws Exception, java.security.InvalidKeyException{
		try{
			SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
			KeySpec spec = new PBEKeySpec(this.password.toCharArray(), this.salt, this.keyIterations, this.keySize);
			SecretKey tmp = factory.generateSecret(spec);
			key = new SecretKeySpec(tmp.getEncoded(), "AES");
		}catch(Exception e){
			throw e;
		}
	}
	
	/**
	 * Check if the createSecretKey function has been successfully called
	 * @return boolean
	 */
	public boolean isKeyGenerated(){
		if (key == null){
			return false;
		}
		return true;
	}
	
	/**
	 * Destroy a SecretKey object, used normally when serializing the object
	 */
	public void destroyKey(){
		this.key = null;
	}
	
	/**
	 * Sets the key to a resolved SecretKeyObject
	 */
	
	public void setKey(SecretKey key){
		this.key = key;
	}
	
	public SecretKey getKey(){
		return this.key;
	}
	
	/**
	 * Encrypt some plain text using the SecretKey generated by this class
	 * use StandardCharsets.UTF_8 to convert to string
	 * @param plain
	 * @return EncryptedString - A composite containing the encrypted byte[] and the IV byte[] the IV bytes <b>MUST</b> be saved!
	 * @throws Exception
	 */
	public EncryptedString encrypt(String plain) throws Exception{
		Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
		cipher.init(Cipher.ENCRYPT_MODE, key);
		AlgorithmParameters params = cipher.getParameters();
		byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();
		byte[] cipherText = cipher.doFinal(plain.getBytes(StandardCharsets.UTF_8));
		return new EncryptedString(cipherText, iv);
	}
	
	/**
	 * Decrypt an encrypted byte array
	 * use StandardCharsets.UTF_8 to convert from string
	 * @param cipherText
	 * @param iv
	 * @return
	 * @throws Exception
	 */
	public String decrypt(byte[] cipherText, byte[] iv) throws Exception{
		Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
		cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));
		String plain = new String(cipher.doFinal(cipherText), StandardCharsets.UTF_8);
		return plain;
	}
	
	/**
	 * Generate a new byte array for the salt parameter
	 * @return byte[]
	 */
	public byte[] generateSalt() {
		SecureRandom random = new SecureRandom();
		byte bytes[] = new byte[8];
		random.nextBytes(bytes);
		return bytes;
	}
	
	//Get and Set
	
	/**
	 * Set the password parameter
	 * Doing this will require the SecreyKey to be regenerated in order for it to have an effect
	 * @param password
	 */
	public void setPassword(String password){
		this.password = password;
	}
	
	/**
	 * Get the password parameter
	 * @return String
	 */
	public String getPassword(){
		return this.password;
	}
	
	/**
	 * Set the salt byte[] parameter
	 * Doing this will require the SecreyKey to be regenerated in order for it to have an effect
	 * @param salt
	 */
	public void setSalt(byte[] salt){
		this.salt = salt;
	}
	
	/**
	 * Get the salt byte[] parameter
	 * @return salt
	 */
	public byte[] getSalt(){
		return this.salt;
	}
	
	/**
	 * Set keySize parameter (The amount of bits the key is in size for example 128-bit)
	 * Doing this will require the SecreyKey to be regenerated in order for it to have an effect
	 * @param size
	 */
	public void setKeySize(int size){
		this.keySize = size;
	}
	
	/**
	 * Get the keySize used in the SecretKey
	 * @return Integer
	 */
	public int getKeySize(){
		return this.keySize;
	}
	
	/**
	 * Get the amount of key iterations (this is a <i>final</i> variable
	 * @return Integer
	 */
	public int getKeyIterations(){
		return this.keyIterations;
	}
	
	/**
	 * Get the String used to define a split in a string that has been formated from a LinkedList
	 * @return String
	 */
	public static String getSplitSequence(){
		return splitSequence;
	}
	
	//Static methods
	
	/**
	 * Format a linked list to a string
	 * this uses a split sequence variable that is final and private to this class
	 * @param list
	 * @return String
	 */
	public static String formatToString(LinkedList <String> list){
		if (list != null){
			if (list.size() > 0){
				String str = "";
				boolean first = true;
				for (String s : list){
					if (!first){
						str = str + splitSequence;
					}else{
						first = false;
					}
					str = str + s;
				}
				return str;
			}else{
				return null;
			}
		}else{
			return null;
		}
	}
	
	/**
	 * Format a string with a splitSequence into a LinkedList
	 * @param str
	 * @return LinkedList <String>
	 */
	public static LinkedList <String> formatToLinkedList(String str){
		if (str != null){
			LinkedList <String> data = new LinkedList <String> ();
			String[] dat = str.split(splitSequence);
			for (String s : dat){
				data.add(s);
			}
			return data;
		}else{
			return null;
		}
	}
	
	/**
	 * Generate a random password
	 */
	
	public static String generateString(){
		return new BigInteger(130, new SecureRandom()).toString(32);
	}
	
}
